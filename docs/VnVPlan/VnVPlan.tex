\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\usepackage{amsmath, mathtools}
\usepackage{amssymb}

\input{../Comments}
\input{../Common}

\newcounter{systnum} %Sistem Test Number
\newcommand{\sthesystnum}{ST\thesystnum}
\newcommand{\sref}[1]{ST\ref{#1}}
\newcounter{utnum} %Unit Test Number
\newcommand{\utheutnum}{UT\theutnum}
\newcommand{\uref}[1]{UT\ref{#1}}

\begin{document}

\title{Project Title: System Verification and Validation Plan for EOMEE} 
\author{Gabriela S\'anchez D\'iaz}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
29-10-2020 & 1.0 & Created VnV first draft \\
12-12-2020 & 1.0 & Add Unit tests and make correction from feedback \\
%Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\tableofcontents

\listoftables

%\listoffigures

\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  T & Test\\
  VnV & Verification and Validation\\
  DD & Data Definition\\
  DEA & Double Electron affinity\\
  DIP & Double Ionization Potential\\
  EA & Electron affinity\\
  \progname& Equation-of-motion for excited states\\
  Exc & Excitation\\
  IM & Instance Model\\
  IP & Ionization Potential\\
  MO & Molecular orbital(s)\\
  HOMO& Highest Occupied Molecular Orbital\\
  LUMO& Lowest Unoccupied Molecular Orbital\\
  R & Requirement\\
  SO & Spinorbital(s)\\
  SRS & Software Requirements Specification\\
  MG & Module Guide\\
  MIS & Module Interface Specification\\
  RDM & Reduced density matrix\\
  TDM & Transition density matrix\\
  2D & Two-Dimensional\\
  4D & Four-Dimensional\\
%  $\mathbf{h}$ & 1-electron integral matrix (a 2D matrix), $h_{pq}$ denotes 
%its 
%  p,q-th element\\
%  $\mathbf{v}$ & 2-electron integral matrix (a 4D tensor), $v_{pqrs}$ is its 
%  p,q,r,s-th element\\
%  $\boldsymbol{\gamma}$ & 1-electron reduced density matrix (a 2D matrix);\\
%                        &$\gamma_{pq}$ denotes its p,q-th element\\
%  $\boldsymbol{\Gamma}$ & 2-electron reduced density matrix (a 4D tensor)\\
%                        &$\Gamma_{pqrs}$ denotes its p,q,r,s-th element\\
%  $\otimes$ & Kronecker product\\
%  idx & Index\\
%  $\epsilon$& Energy (in Hartree) of a spinorbital\\
%  $\mathbb{R}^{m \times n}$& A 2D matrix with dimensions $m$, $n$\\
%  $\mathbb{R}^{m \times n \times l \times k}$& A 4D tensor with dimensions 
%$m$, 
%  $n$, $l$, $k$\\
%  \bottomrule
\end{tabular}\\

\subsection{Notation}
\an{This section was introduced to avoid issues with long tables splitting 
twrough pages.}\\
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
	\toprule		
	\textbf{symbol} & \textbf{description}\\
	\midrule
	$\mathbf{h}$ & 1-electron integral matrix (a 2D matrix),\\
	& $h_{pq}$ denotes its p,q-th element\\
	$\mathbf{v}$ & 2-electron integral matrix (a 4D tensor),\\
	& $v_{pqrs}$ is its p,q,r,s-th element\\
	$\boldsymbol{\gamma}$ & 1-electron reduced density matrix (a 2D matrix);\\
	&$\gamma_{pq}$ denotes its p,q-th element\\
	$\boldsymbol{\Gamma}$ & 2-electron reduced density matrix (a 4D tensor)\\
	&$\Gamma_{pqrs}$ denotes its p,q,r,s-th element\\
	$\otimes$ & Kronecker product\\
	idx & Index\\
	$\epsilon$& Energy (in Hartree) of a spinorbital\\
	$\mathbb{R}^{m \times n}$& A 2D matrix with dimensions $m$, $n$\\
	$\mathbb{R}^{m \times n \times l \times k}$& A 4D tensor with dimensions 
	$m$, 
	$n$, $l$, $k$\\
	\bottomrule
\end{tabular}\\
%\wss{symbols, abbreviations or acronyms -- you can simply reference the SRS
%  \citep{SRS} tables, if appropriate}
\newline For more details about symbols, abbreviations and acronyms see 
Sections 1.2 and 
1.4 in \cite{SRS2020}.

\newpage

\pagenumbering{arabic}

This document describes the procedures to determine whether the specified 
requirements for EOMEE were satisfied [\cite{SRS2020}]. It is organized as 
follows: Section \ref{section:geninfo} gives general information about the 
software. The project reviewers and verification plans for the documentation 
and implementation are introduced under Section \ref{section:plans}. The system 
tests (black box tests) are specified in Section \ref{section:systemtests} 
including the verification of the functional and nonfunctional requirements. 
Section \ref{section:unittest} describes the unit tests (white box tests). 
Finally, traceability matrices between system tests and requirements, and 
between unit tests and modules (see Module Guide [\cite{MG2020}]) can be found 
in Subsections \ref{section:systemtraceability} and 
\ref{section:unittraceability}, respectively.

\section{General Information}
\label{section:geninfo}

\subsection{Summary}

%\wss{Say what software is being tested.  Give its name and a brief overview of
%  its general functions.}\\
The present document presents the validation plan of the package Equation of 
Motion for Excited States (EOMEE). This program is intended as a research tool 
for evaluating excited states (including ionized states) and their related 
spectroscopic properties such as the oscillator strengths. It also strives to 
assess the effect of the electron correlation on these properties.

\subsection{Objectives}

%\wss{State what is intended to be accomplished.  The objective will be around
%  the qualities that are most important for your project.  You might have
%  something like: ``build confidence in the software correctness,''
%  ``demonstrate adequate usability.'' etc.  You won't list all of the 
%qualities,
%  just those that are most important.}\\
The present document's aim is to build confidence in the software by designing 
tests that verify its correctness (compliance with the requirements). 
Validation of the inputs and outputs or the 
code usability will be among the main tests this plan will be focusing on.

\subsection{Relevant Documentation}

%\wss{Reference relevant documentation.  This will definitely include your SRS
%  and your other project documents (MG, MIS, etc)}

Through this document we will be referring to the requirement specifications 
for EOMEE [\citet{SRS2020}], in particular to its functional and nonfunctional 
requirements. Additionally, details about the module design can be found in the 
Module Guide (MG) [\cite{MG2020}] and Module Interface Specification (MIS) 
[\cite{MIS2020}].

\section{Plan}
\label{section:plans}

\subsection{Verification and Validation Team}

%\wss{You, your classmates and the course instructor.  Maybe your supervisor.}\\
The review of EOMEE will be conducted by the following parties:
\begin{itemize}
	\item The Ayers Lab members, in particular Michael Richer, Dr.\ Paul Ayers 
	and Gabriela S\'anchez D\'iaz.
	\item Dr.\ Spencer Smith.
	\item Members of 2020 CAS741 course; in particular the following 
	responsibilities have been defined:
	\subitem Mohamed AbuElAla (Primary Reviewer)
	\subitem Seyed Parsa Tayefeh Morsal (SRS Reviewer)
	\subitem Ting-Yu Wu (VnV Reviewer)
	\subitem Xuanming Yan (MG and MIS Reviewer)
\end{itemize}

\subsection{SRS Verification Plan}

The Software Requirement Specifications (SRS) verification should be carried by 
the reviewers following the indications below:\\
The SRS document [\cite{SRS2020}] will be provided to Dr.\ Ayers, Dr.\ 
Smith, Mohamed AbuElAla and Gabriela S\'anchez along with a questionnaire (to 
be found in the Appendix section \ref{section:srsreview}). The reviewers 
will read the document and questions and report any problems or 
inconsistencies as GitHub issues in the project's repository 
(\href{https://github.com/gabrielasd/eomee/tree/cas741} 
{cas741})

\subsection{Design Verification Plan}

%\wss{Plans for design verification}
The modules design (see MG [\cite{MG2020}] and MIS [\cite{MIS2020}]) will be 
discussed with the review team members Dr.\ Paul Ayers and Michael Richer. It 
will also be presented to/evaluated by Dr.\ Smith and the members of 2020 
CAS741 course. The review process will be guided by the MG and MIS checklists  
that can be accessed as part of the course materials (\cite{mgcheck} and 
\cite{mischeck}, respectively). Design problems or inconsistencies will be 
reported as GitHub issues in EOMEE's repository 
(\href{https://github.com/gabrielasd/eomee/tree/cas741}{cas741}).

\subsection{Implementation Verification Plan}

%\wss{You should at least point to the tests listed in this document and the 
%unit
%  testing plan.}
%
%\wss{In this section you would also give any details of any plans for static 
%verification of
%  the implementation.  Potential techniques include code walkthroughs, code
%  inspection, static analyzers, etc.}\\
The implementation will be verified through system and unit testing. The 
following test areas will be defined:
\begin{itemize}
	\item \textbf{Subsection} \ref{section:inputs} Input Verification: 
	checks for valid input variables.
	
	\item \textbf{Subsection} 
	\ref{section:calculations} Energies and TDMs Evaluation: verification of 
	the calculation results corresponding to IM1-IM6 (see Section 4.2.5 of the 
	SRS \cite{SRS2020}).
	
	\item \textbf{Subsection} \ref{section:usability} Usability Verification 
	Plan: tests with the purpose of identifying potential deficiencies in the 
	user-software interaction.
	
	\item \textbf{Subsection} \ref{section:reusability} Reusability 
	verification: check whether the modular decomposition of the software was 
	done correctly.
	
	\item \textbf{Subsection} \ref{section:performance} Performance: check the 
	numerical stability of the eigenvalue solution method for the implemented 
	IM1-IM5 [\cite{SRS2020}].

	\item \textbf{Subsection} \ref{sec:M3} Input Module: Unit tests for the 
	type and values of the inputs.

	\item \textbf{Subsection} \ref{sec:M4} Integrals Module: Unit tests of 
	electron integrals format.
	
	\item \textbf{Subsection} \ref{sec:M5} Density Module: Unit tests of 
	density matrices format.
	
	\item \textbf{Subsection} \ref{sec:M12} Solver Module: Unit tests for the 
	solver orthogonalization method.
	
	\item \textbf{Subsection} \ref{sec:M13} Output Module: Unit tests for the 
	output formats.
\end{itemize}

\subsection{Automated Testing and Verification Tools}
 
We will be using \href{https://docs.pytest.org/en/stable/} 
{Pytest} testing framework for tests automation  with the plugin 
\href{https://pytest-cov.readthedocs.io/en/latest/} {pytest-cov} to 
determine the code coverage percentage. Additionally, the following tools 
will be 
used to enforce compliance with Python style 
conventions for code and documentation:
\begin{itemize}
\item \href{https://www.pylint.org/} {Pylint}, 
\href{https://flake8.pycqa.org/en/latest/} {Flake8} and 
\href{https://black.readthedocs.io/en/stable/#} {Black} as Python linters. The 
last one is also a code auto-formatter. 
\item \href{https://pypi.org/project/flake8-docstrings/} {flake8-docstrings} as 
a static analysis for Python docstring conventions.
\end{itemize}
For continuous integration we will use the \href{https://travis-ci.org/} 
{Travis-CI} tool.

\subsection{Software Validation Plan}

%\wss{If there is any external data that can be used for validation, you should
%  point to it here.  If there are no plans for validation, you should state 
%that
%  here.}
To verify EOMEE results, in particular during the system tests, 
these will be compared against the ones obtained with the package for 
electronic structure calculations Gaussian [\cite{g16}]. Additionally, a source 
for validation can be the NIST Atomic Spectra Database[\cite{NIST_ASD}].

\section{System Test Description}
\label{section:systemtests}
	
\subsection{Tests for Functional Requirements}

%\wss{Subsets of the tests may be in related, so this section is divided into
%  different areas.  If there are no identifiable subsets for the tests, this
%  level of document structure can be removed.}
%
%\wss{Include a blurb here to explain why the subsections below
%  cover the requirements.  References to the SRS would be good.}
The tests described in the following subsections check functional requirements 
listed in the subsection 5.1 of the 
\href{https://github.com/gabrielasd/eomee/tree/cas741/docs/SRS} {SRS}, in 
particular requirements R1 and R2 about the input variables and R4 and R5 
related to the spectroscopic properties evaluated by EOMEE.

\subsubsection{Input Verification}
\label{section:inputs}

%\wss{It would be nice to have a blurb here to explain why the subsections below
%  cover the requirements.  References to the SRS would be good.  If a section
%  covers tests for input constraints, you should reference the data constraints
%  table in the SRS.}

\paragraph{Valid and invalid inputs}

\begin{enumerate}

\item{valid\_inputs: ST\refstepcounter{systnum}\thesystnum \label{ST1}\\}
Control: Automatic
					
Initial State: N/A

Input: The following sample input files stored under \textit{test/data/}:
\begin{itemize}
	\item file1: test\_input1.in
	\item file2: test\_input2.in
	\item file3: test\_input3.in
	\item file4: test\_input4.in
	\item file5: test\_input5.in
\end{itemize}				

Each of this files uses a different EOM method as shown in column 3 of 
Table~\ref{table:validins} 
\begin{table}[h!]
	\centering
	\begin{tabular}{lccc}
		Case&File  & Method & Expected \# outputs   \\ \midrule
		C1&file1 &   IP   &          2           \\
		C2&file2 &   EA   &          3            \\
		C3&file3 &  Exc   &          2            \\
		C4&file4 &  DIP   &          2            \\
		C5&file5 &  DEA   &          2            \\ \bottomrule
	\end{tabular}
	\caption{Test cases for valid input parameters. The last column indicates 
	the expected number of files to be produced as output.}
	\label{table:validins}
\end{table}
The istegrals and RDMs used in these tests are the same as detailed in 
Table~\ref{table:datains}
\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		Parameters& Value\\
		\midrule
		oneint\_file& test/data/be\_sto3g\_oneint\_spino.npy\\
		twoint\_file & test/data/be\_sto3g\_twoint\_spino.npy\\ 
		dm1\_file & test/data/be\_sto3g\_onedm\_spino.npy\\
		dm2\_file & test/data/be\_sto3g\_twodm\_spino.npy\\
		\bottomrule
	\end{tabular}
	\caption{Common parameters between all input files.}
	\label{table:datains}
\end{table}
	
Output: The number of output files specified in the last column of 
Table~\ref{table:validins}

Test Case Derivation: N/A
					
How test will be performed: The test module will feed the inputs, as specified 
in Table~\ref{table:validins}, to the EOMEE code and verify that the expected 
number of files is generated.

\item{invalid\_inputs: ST\refstepcounter{systnum}\thesystnum \label{ST2}\\}

Control: Automatic

Initial State: N/A

Input: The following input files stored under \textit{test/data/}: 
\begin{itemize}
	\item file1: test\_input\_mos.in
	\item file2: test\_wrong\_dms.in
\end{itemize}
The options inside each file that will cause the program to fail are specified 
next (Table~\ref{table:wrongdata}):
\begin{table}[h!]
	\centering
	\begin{tabular}{lll}
		File&Parameters& Value\\
		\midrule
		file1&oneint\_file& test/data/be\_sto3g\_oneint.npy\\
		file1&twoint\_file & test/data/be\_sto3g\_twoint.npy\\ 
		file2&dm1\_file & test/data/b\_sto3g\_onedm\_spino.npy\\
		file1&dm2\_file & test/data/b\_sto3g\_twodm\_spino.npy\\
		\bottomrule
	\end{tabular}
	\caption{Incorrect parameters on each input files.}
	\label{table:wrongdata}
\end{table}

Output: A ValueError exception is raised 

Test Case Derivation: In file1 the electron integrals are in the incorrect 
format (molecular orbital (MO) basis instead of the spinorbital one (SO)) (see 
Table~\ref{table:wrongdata}), therefore their symmetry will not match the one 
expected by EOMEE. For the other input file (file2) the density matrices used 
correspond to a different system than the electron integrals, therefore the 
number of electrons associated with the trace of this matrices won't match the 
expected value (specified by nelec in the input file).

How test will be performed: The testing framework 
will pass the inputs to EOMEE and verify that a ValueError is raised.

\end{enumerate}

\subsubsection{Energies and TDMs Evaluation}
\label{section:calculations}

\paragraph{Transition energies\\}

The tests described under this section require the one- and 
two-electron integrals for the N-electron, M-atom system to be stored in the 
directory \textit{test/data} as \href{https://numpy.org/} {NumPy}'s binary 
files (.npy). Unless otherwise 
stated, for each implemented EOM method (IM1-IM5, 
\href{https://github.com/gabrielasd/eomee/tree/cas741/docs/SRS} {SRS} 
subsection 4.2.5), the lowest (positive valued) 
transition energy will be taken and compared against an ``expected" energy 
value 
(generally from a Gaussian [\cite{g16}] calculation). 
Because at this point we are not targeting the performance of the 
methods, only small systems with at most 5 electrons and 10 MOs were included 
in the test cases below. We will use the absolute error 
($|E_{IM\#} - E_{expected}|$) to measure the method's accuracy.
%Electronic structure calculations are said to have chemical accuracy if their 
%prediction error is around 1 kcal/mol (0.043 eV) relative to the experiment. 
%Reliable methods for excitation energies computation such as 
%EOM-CCSD~\cite{Stanton1993} provide an accuracy of 
%0.1â€“0.2 eV (absolute error) for sinlge-excitations.\\


\begin{enumerate}
	
	\item{correct-lowest-transition: ST\refstepcounter{systnum}\thesystnum 
	\label{ST3}\\}
	
	Control: Automatic
	
	Initial State: N/A
	
	Input: The one- and two-electron integrals corresponding to the systems 
	presented in Table~\ref{table:energies}, the tolerance value $1.0 \times 
	10^{-6}$.\\
	
	Table~\ref{table:energies} contains the test cases 
	description. All systems have closed-shell electronic configurations except 
	the boron atom (B). The $\epsilon_{HOMO}$ and 
	$\epsilon_{LUMO}$ values for the atomic and molecular systems are reported 
	in Table~\ref{table:koopman}.

	\begin{table}[h!]
		\centering
		\begin{tabular}{l c c c c}
			\toprule
			\textbf{File} & IM &\textbf{Nbasis} & \textbf{Nocc}& 
			\textbf{Expected}\\
			\midrule
			B (STO-3G) & 1 & 5& (3, 2)& $-\epsilon_{HOMO}$\\
			B (STO-3G) & 2 & 5& (3, 2)& $\epsilon_{LUMO}$\\
			He (cc-pVDZ)& 1& 5& (1, 1)& $-\epsilon_{HOMO}$\\
			He (cc-pVDZ)& 2& 5& (1, 1)& $\epsilon_{LUMO}$\\
			$HeH^{+}$ (STO-3G)& 1 & 2& (1, 1)& $-\epsilon_{HOMO}$\\
			$HeH^{+}$ (STO-3G)& 2 & 2& (1, 1)& $\epsilon_{LUMO}$\\
			$HeH^{+}$ (STO-3G)& 3 & 2& (1, 1)& 0.91123209\\
			$H_2$ (STO-6G)& 4 & 2& (1, 1)& 1.83843430\\			
		\end{tabular}
		\caption{Input variables. The reference energy values (last column) are 
		in Hartree.}
		\label{table:energies}
	\end{table}

	\begin{table}[h!]
		\centering
		\begin{tabular}{l c c}
			\toprule
			\textbf{File} & $\epsilon_{HOMO}$ & $\epsilon_{LUMO}$\\
			\midrule
			B (STO-3G) &-0.20051823& 0.29136562\\
			He (cc-pVDZ)& -0.91414765& 1.39744193\\
			$HeH^{+}$ (STO-3G)& -1.52378328 & -0.26764028\\		
		\end{tabular}
		\caption{Frontier MO energies in Hartree.}
		\label{table:koopman}
	\end{table}
	
	Output: Eigenvalues (and eigenvectors) solution to the IMs.
	
	Test Case Derivation: 
	The one- and two-reduced density matrices required  as input by the EOMEE 
	methods will be generated from the number of electrons (Nocc) and MOs 
	(Nbasis). Because the ground state wave function ($\Psi_0$) for the 
	systems in Table~\ref{table:energies} will be modeled 	by a single Slater 
	determinant (specifically the lowest energy Hartree-Fock Slater 
	determinant), the one- and two-RDMs can be defined as:
	\begin{align*}
	\gamma_{pq} &=\Bigg\{
	\begin{matrix}
	\delta_{pq}& p,q \in \text{occupied MO}\\
	0 & \text{virtual MO}
	\end{matrix}\\
	\Gamma_{pqrs} &= \frac{1}{\sqrt{2}}(\gamma_{pr}\gamma_{qs} - 
	\gamma_{ps}\gamma_{qr})
	\end{align*} 
	
	How test will be performed:
	The testing framework will pass the electron integrals and density matrices 
	to the EOM method (IM column in Table~\ref{table:energies}). From the 
	solutions, the lowest transition energy will be determined and compared 
	against the ``expected" value. If the absolute error is less or 
	equal than the tolerance criteria, the test will pass.

	
\end{enumerate}


\paragraph{Transition Density Matrices}

\begin{enumerate}
	
	\item{matrix-symmetry: ST\refstepcounter{systnum}\thesystnum \label{ST4}\\}
	
	Control: Automatic
	
	Initial State: The EOM method (IM1-IM5) has been solved.
	
	Input: The following input arrays located in the \textit{test/data} folder:
	\begin{itemize}
		\item be\_sto3g\_twoint\_genzd\_anti.npy
		\item 2dm\_be\_sto3g\_genzd\_anti.npy
		\item be\_sto3g\_oneint\_genzd.npy
		\item 1dm\_be\_sto3g\_genzd.npy
	\end{itemize}
	The expansion coefficients matrix and the lowest nonzero excited state 
	index. 
	
	Output: The TDM for the selected state.
	
	Test Case Derivation: The equations to evaluate the TDMs corresponding to 
	each EOM method can be found in the 
	\href{https://github.com/gabrielasd/eomee/tree/cas741/docs/SRS} 
	{SRS} (subsection 4.2.5, IM6).
	
	How test will be performed: 
	The test framework will pass the specified inputs to a function that 
	evaluates the EOMEE methods and TDMs. The selected TDM and its transpose 
	will be compared using NumPy's allclose method. The test will pass if the 
	matrix is asymmetric. 
	
\end{enumerate}


\subsection{Tests for Nonfunctional Requirements}

%\wss{The nonfunctional requirements for accuracy will likely just reference the
%  appropriate functional tests from above.  The test cases should mention
%  reporting the relative error for these tests.}
%
%\wss{Tests related to usability could include conducting a usability test and
%  survey.}
The tests described in the following subsections verify the nonfunctional 
requirements listed in the subsection 5.2 of the 
\href{https://github.com/gabrielasd/eomee/tree/cas741/docs/SRS} {SRS}.

\subsubsection{Usability verification}
\label{section:usability}

\paragraph{Portability and usability tests}

\begin{enumerate}
	
	\item{installability-test: ST\refstepcounter{systnum}\thesystnum 
	\label{ST5}}
	
	Type: Manual
	
	Initial State: There may or may not be some Python program and modules 
	already installed.
	
	Input/Condition: Internet connection and some web browser available.
	
	Output/Result: EOMEE module installed or issue reported in GitHub.
	
	How test will be performed: 
	The GitHub repository will be cloned by Gabriela S\'anchez in different 
	platforms (Ubuntu Focal 
	Fossa, Mac OS Catalina and Windows 10). The installation will follow the 
	instructions in the README.md file located on the repository root folder. 
	Upon installation completion the system and unit tests will be ran. 

	\item{usability-test: ST\refstepcounter{systnum}\thesystnum \label{ST6}\\}
	\label{sec:usability}
	
	Type: Manual.
	
	Initial State: The EOMEE code may or not be installed on the user's 
	computer.
	
	Input/Condition: Members of the test team, the link to the project's GitHub 
	repository and the following example input files for the beryllium atom:
	\begin{itemize}
		\item be\_sto3g\_twoint\_genzd\_anti.npy
		\item 2dm\_be\_sto3g\_genzd\_anti.npy
		\item be\_sto3g\_oneint\_genzd.npy
		\item 1dm\_be\_sto3g\_genzd.npy
	\end{itemize}
	These files will be located in the \textit{test/data} folder.
	
	Output/Result: Users response to the usability survey found in the Appendix 
	section.
	
	How test will be performed: The users will clone the repository and install 
	the program. Using the provided input files they will choose to evaluate 
	one of the following properties for Be: ionization potential, electron 
	affinity or electron excitation. Additionally, they will determine the TDMs 
	for their selected method. After completing these tasks the test team will 
	fill out the survey.
	
	
\end{enumerate}

\subsubsection{Reusability verification}
\label{section:reusability}

%\paragraph{Numerical instability}

\begin{enumerate}
	
	\item{reusability-test: ST\refstepcounter{systnum}\thesystnum \label{ST7}}
	
	Type: Manual
	
	Initial State: An existing (working) implementation of EOMEE.
	
	Input/Condition: The input file test\_input\_mos.in (located under 
	\textit{text/data/})
	This file has the usual inputs, but with the electron 
	integral parameters pointing to the following files in MO basis 
	set format instead of the SO one:
	\textit{text/data/}
	\begin{itemize}
		\item be\_sto3g\_oneint.npy
		\item be\_sto3g\_twoint.npy
	\end{itemize}
	
	Output/Result: The program is ran the same way as before (passing an input 
	file to a control module), but using electron integrals in the MO basis set.
	
	How test will be performed: The Integrals module (Section 8 of MIS 
	[\cite{MIS2020}]) will be modified. Three new functions will be added, one 
	to transform the integrals format from MO to SO basis, the 
	other two to give the two-electron integrals the symmetry properties they 
	should have to work with the EOM modules. If after the changes performed 
	the code produces de same result as with the old file format (integral 
	files be\_sto3g\_oneint\_spino.npy and be\_sto3g\_twoint\_spino.npy) the 
	test is considered passed.
	
\end{enumerate}

\subsubsection{Performance}
\label{section:performance}

\paragraph{Numerical instability}

\begin{enumerate}
	
	\item{illconditioning-test: ST\refstepcounter{systnum}\thesystnum 
	\label{ST8}}
	
	Type: automatic
	
	Initial State: N/A
	
	Input/Condition: A matrix orthogonalization methods (strings 
	\textit{symmetric} or \textit{asymmetric}), threshold values in the range 
	$1.0 \times 10^{-4} - 1.0 \times 10^{-9}$, the example input files from the
	\hyperref[section:usability]{usability-test} and the instance models IM1 to 
	IM5 (\href{https://github.com/gabrielasd/eomee/tree/cas741/docs/SRS} {SRS} 
	subsection 4.2.5).
	
	Output/Result: A graph showing how the lowest nonzero value for instance 
	models IM1-IM5 changes with the tolerance value.
	
	How test will be performed: The test framework will pass the inputs to 
	EOMEE and a graph will be generated.
	
\end{enumerate}


\subsection{Traceability Between Test Cases and Requirements}
\label{section:systemtraceability}

%\wss{Provide a table that shows which test cases are supporting which
%  requirements.}
Table~\ref{table:traceab} shows what requirement specifications the functional and nonfunctional system tests address:

\begin{table}[ht]
	\centering
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|}
		\hline
		& \sref{ST1}& \sref{ST2}& \sref{ST3}& \sref{ST4}& \sref{ST5}& 
		\sref{ST6}& \sref{ST7}& \sref{ST8}\\	\hline	
	  R1& X& & & & & & &\\ \hline
	  R2&  & X& & & & & &\\ \hline
	  R3&  & X& & & & & &\\ \hline
	  R4&  &  & X& X& & & & \\ \hline
	  R5&  &  & X& X& & & &\\ \hline
	  Reusability& & & & & & &  X& \\ \hline
	  Usability& & & & &   X& X& &\\ \hline
	  Portability& & & &   & X& && \\ \hline
	  Accuracy& & & X& X&  &  & & X\\ \hline
	\end{tabular}
	\caption{Traceability for system tests and requirements}
	\label{table:traceab}
\end{table}

\section{Unit Test Description}
\label{section:unittest}

\wss{Reference your MIS and explain your overall philosophy for test case
  selection.}  
\wss{This section should not be filled in until after the MIS has
  been completed.}

\subsection{Unit Testing Scope}
\label{sec:unitscope}

\wss{What modules are outside of the scope.  If there are modules that are
  developed by someone else, then you would say here if you aren't planning on
  verifying them.  There may also be modules that are part of your software, but
  have a lower priority for verification than others.  If this is the case,
  explain your rationale for the ranking of module importance.}

In the subsequent sections the unit tests for the modules specified in the MG 
and MIS are described (see \cite{MG2020} and \cite{MIS2020}, respectively). The 
verification of the Control (M2) and EOM modules (M6-M11) is mainly performed 
through black box testing (refer to Section \ref{section:calculations}), 
therefore these modules are not considered in this part of the document. 
Similarly, the Hardware-Hiding module (M1) related to the operating system on 
which the program runs will not be verified.

\subsection{Tests for Functional Requirements}

%\wss{Most of the verification will be through automated unit testing.  If
%  appropriate specific modules can be verified by a non-testing based
%  technique.  That can also be documented in this section.}

%\subsubsection{Module 1}
%
%\wss{Include a blurb here to explain why the subsections below cover the 
%module.
%  References to the MIS would be good.  You will want tests from a black box
%  perspective and from a white box perspective.  Explain to the reader how the
%  tests were selected.}
%
%\begin{enumerate}
%
%\item{test-id1\\}
%
%Type: \wss{Functional, Dynamic, Manual, Automatic, Static etc. Most will
%  be automatic}
%					
%Initial State: 
%					
%Input: 
%					
%Output: \wss{The expected result for the given inputs}
%
%Test Case Derivation: \wss{Justify the expected value given in the Output 
%field}
%
%How test will be performed: 
%					
%\item{test-id2\\}
%
%Type: \wss{Functional, Dynamic, Manual, Automatic, Static etc. Most will
%  be automatic}
%					
%Initial State: 
%					
%Input: 
%					
%Output: \wss{The expected result for the given inputs}
%
%Test Case Derivation: \wss{Justify the expected value given in the Output 
%field}
%
%How test will be performed: 
%
%\item{...\\}
%    
%\end{enumerate}

\subsubsection{Input Module}
\label{sec:M3}

The interface of the Input  module is described in [\cite{MIS2020}]. It 
requires as input a file with line-separated instructions and stores the parsed 
parameters in a data structure (called ParsedParams in the MIS). The tests 
bellow aim at checking that the module is able to parse an input file correctly 
(test\_parse\_inputfile) and that incorrect input variables are detected 
(test\_wrong\_inputs). Table~\ref{table:loaddata} lists common input variables 
between these tests. The parameters file1 and file2 correspond to sample input 
files that should be located under the package's \textit{test/data} folder.
\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		Parameters& Value\\
		\midrule
		file1& test/data/test\_input1.in\\
		file2 & test/data/test\_input2.in\\ 
		oneint1 & be\_sto3g\_oneint\_spino.npy\\
		twoint1 & be\_sto3g\_twoint\_spino.npy\\
		onedm1 & be\_sto3g\_onedm\_spino.npy\\
		twodm1 & be\_sto3g\_twodm\_spino.npy\\
		orthog& symmetric\\
		eom& ip\\
		\bottomrule
	\end{tabular}
	\caption{Common parameters used by Input module tests.}
	\label{table:loaddata}
\end{table}

\begin{enumerate}
	
	\item{test\_parse\_inputfile: UT\refstepcounter{utnum}\theutnum 
	\label{UT1}}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The files file1 and file2 from Table~\ref{table:loaddata}. Each file 
	is a test case (C1 and C2 respectively).

	Output: For tests C1 and C2 the output is a data structure storing the 
	parsed input data as variables (ParsedParams). The expected stored values 
	are reported in Table~\ref{table:loadcases}. The common variables between 
	the two tests are listed in Table~\ref{table:loaddata} (oneint1, twoint1, 
	onedm1, 
	twodm1, orthog, eom).
	\begin{table}[h!]
		\centering
		\begin{tabular}{lcc}
			& \multicolumn{2}{c}{Test Cases} \\
			Parameters             &  C1  &  C2  \\
			nelec                  & (2, 2) & 4  \\
			get\_tdm                 &  False   &  True   \\
			roots                &  None  &  1\\
			tol& 1.0e-7& 1.0e-6\\  
		\end{tabular}
		\caption{Input module stored parameters. Column 1 
			specifies the variables, columns C1 and C2 their expected values 
			for each test case.}
		\label{table:loadcases}
	\end{table}
	
	Test Case Derivation: While the values for column C2 in 
	Table~\ref{table:loaddata} are parsed from the input file file2, the values 
	for C1 are the defaults assigned by the module when their corresponding 
	parameters aren't included in the input file (file1)
	
	How test will be performed: The test framework will pass the input files to 
	the module and verify that the expected outputs were obtained.
	
	\item{test\_wrong\_inputs:  UT\refstepcounter{utnum}\theutnum 
		\label{UT2}}
	
	Type: Automatic
	
	Initial State: 
	
	Input: A list of input parameters as specified in 
	Table~\ref{table:wrongcases}:
	\begin{table}[h!]
		\centering
		\begin{tabular}{lcc}
			Parameter & Wrong\_Value &     Exception     \\
			\toprule
			nelec      &     0.1      &     TypeError     \\
			tol        &      4       &     TypeError     \\
			roots      &     0.1      &     TypeError     \\
			get\_tdm   &     yes      &     TypeError     \\
			h\_file    &   temp.npy   & FileNotFoundError \\
			v\_file    &   temp.npy   & FileNotFoundError \\
			dm1\_file  &   temp.npy   & FileNotFoundError \\
			dm2\_file  &   temp.npy   & FileNotFoundError \\
			orthog     &      ip      &    ValueError     \\
			eom        &  symmetric   &    ValueError\\
			\bottomrule
		\end{tabular}
		\caption{Invalid input values.  Column 3 
			specifies the expected raised exception.}
		\label{table:wrongcases}
	\end{table}
	
	Output: An exception will be raised according to 
	Table~\ref{table:wrongcases}.
	
	Test Case Derivation: Starting from a list containing the valid parsed 
	instructions from file2 (see Table~\ref{table:loaddata} for its location), 
	they are assigned incorrectly to ParsedParams variables as specified in 
	Table~\ref{table:wrongcases}.
	
	How test will be performed: The test framework will pass the input to 
	the module and verify that the expected exceptions are raised.
	
\end{enumerate}

\subsubsection{Integrals Module}
\label{sec:M4}

Section 8 of MIS [\cite{MIS2020}] describes the interface of the Integrals 
module, which handles the format of the electron integrals. The unit tests 
bellow check that the input files are loaded correctly (test\_load\_integrals) 
and that integrlas with wrong properties be detected 
(test\_check\_invalid\_integrals, test\_verify \_symmetry) . The parameters 
used for this tests are listed in Table~\ref{table:intdata}.
The data files with extensions .in and .npy should be located under the 
package's \textit{test/data} folder.
\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		Parameters& Value\\
		\midrule 
		file1 & test/data/test\_input1.in\\
		oneint1 & be\_sto3g\_oneint\_spino.npy\\
		twoint1 & be\_sto3g\_twoint\_spino.npy\\
		oneint2 & h2\_hf\_sto6g\_oneint.npy\\
		twoint2 & h2\_hf\_sto6g\_oneint.npy\\
		A &$\mathbb{R}^{m \times m}$ (e.g. [[1,2], [3,4]])\\
		 &with the condition $A \not= A^{T}$\\
		B &$\mathbb{R}^{m \times m \times m \times m}$ (e.g. 
		np.arange(16).reshape(2, 
		2, 2, 2))\\
		&with the condition $B \not= B^{T}$\\
		C &$\mathbb{R}^{m \times m \times n \times n}$ (e.g. 
		np.zeros((2, 2, 3, 3)))\\
		nspins&10\\
		\bottomrule
	\end{tabular}
	\caption{Parameters used by the Integrals module tests.}
	\label{table:intdata}
\end{table} 

\begin{enumerate}
	
	
	\item{test\_load\_integrals:  UT\refstepcounter{utnum}\theutnum 
		\label{UT3}}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The files oneint1 and twoint1 (see Table~\ref{table:intdata}).
	
	Output: the loaded integral matrices and the number of spinorbitals.
	
	Test Case Derivation: N/A
	
	How test will be performed:  Automated on unit testing framework. The 
	content of oneint1 and twoint1 will be read and stored externally into 
	variables and compared against the ones loaded by the module. The number of 
	sinorbitals will be compared with nspins (reported in 
	Table~\ref{table:intdata}).
	
	\item{test\_check\_invalid\_integrals:  UT\refstepcounter{utnum}\theutnum 
		\label{UT4}}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The electron integrals as specified for each test case (C1-C7) in 
	Table~\ref{table:wrongints}. The values of the variables in columns 2 and 3 
	are reported in Table~\ref{table:intdata}.
	\begin{table}[h!]
		\centering
		\begin{tabular}{lccc}
			Case & $\mathbf{h}$ & $\mathbf{v}$ & Exception  \\ \toprule
			C1   &    file1     &   twoint1    & ValueError \\
			C2   &      4       &   twoint1    & TypeError  \\
			C3   &   oneint1    &      4       & TypeError  \\
			C4   &   twoint1    &   twoint1    & ValueError \\
			C5   &   oneint1    &   oneint1    & ValueError \\
			C6   &   oneint1    &      C       & ValueError \\
			C7   &   oneint1    &      B       & ValueError \\ \bottomrule
		\end{tabular}
		\caption{Invalid input values. Seven test cases are defined (C1-C7) 
		with corresponding input files in columns 2 and 3. Column 4 
			specifies the expected raised exception.}
		\label{table:wrongints}
	\end{table}	

	Output: An exception will be raised according to 
	Table~\ref{table:wrongints}.
	
	Test Case Derivation: For C1 the $\mathbf{h}$ file is not a NumPy .npy. In 
	C2 and C3, $\mathbf{h}$ integers are passed as inputs instead of matrices. 
	The remaining test cases use inputs with incorrect number of dimensions 
	($\mathbf{h}$ has to be a square matrix, $\mathbf{v}$ must be 4D with 
	equivalent dimensions)
	
	How test will be performed: The test framework will pass the inputs to 
	the Integrals module and verify that the expected exceptions are raised.
	
	\item{test\_verify\_symmetry:  UT\refstepcounter{utnum}\theutnum 
		\label{UT5}}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The electron integrals for each test case (C1-C3) are listed in 
	columns 2 and 3 of Table~\ref{table:symmints}. The variables 
	are reported in Table~\ref{table:intdata}.
	\begin{table}[h!]
		\centering
		\begin{tabular}{lccc}
			Case & $\mathbf{h}$ & $\mathbf{v}$ & Exception  \\ \toprule
			C1   &      A       &   twoint2    & ValueError \\
			C2   &   oneint2    &      B       & ValueError \\
			C3   &   oneint2    &   twoint2    & ValueError \\ \bottomrule
		\end{tabular}
		\caption{Invalid input values. Three test cases are defined (C1-C3) 
			with corresponding input files in columns 2 and 3. Column 4 
			specifies the expected raised exception.}
		\label{table:symmints}
	\end{table}	
	
	Output: An exception raised as indicated in Table~\ref{table:symmints}.
	
	Test Case Derivation: The matrices A and B must not have any element of 
	symmetry. While the file oneint2 has the correct symmetry for a 
	one-electron integral, twoint2 does not meet the asymmetric permutations of 
	a two-electron interal (see Eq.~(8) for Data Definition 3 in SRS 
	[\cite{SRS2020}]).
	
	How test will be performed: Automated on unit testing framework.
	
\end{enumerate}

\subsubsection{Density Module}
\label{sec:M5}

The Density module handles the format of the RDMs; its interface is specified in
Section 9 of the MIS [\cite{MIS2020}]. The tests to verify that the RDMs have 
the right characteristics to be used in an EOM calculation are described below. 
The first unit test only checks that module is able to load a valid input
(test\_assign\_rdms). The remaining tests are to detect incorrect inputs given 
by the type, or symmetry properties of the inputs (test\_check\_invalid\_rdms, 
test\_verify\_symmetry, test\_verify\_normalization). The parameters 
used through this tests are listed in Table~\ref{table:dmdata}.
The data files with extensions .in and .npy should be located under the 
package's \textit{test/data} folder.
\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		Parameters& Value\\
		\midrule 
		file1 & test/data/test\_input1.in\\
		onedm1 & be\_sto3g\_onedm\_spino.npy\\
		twodm1 & be\_sto3g\_twodm\_spino.npy\\
		twoint2 & h2\_hf\_sto6g\_oneint.npy\\
		A &$\mathbb{R}^{m \times m}$ (e.g. [[1,2], [3,4]])\\
		&with the condition $A \not= A^{T}$\\
		B &$\mathbb{R}^{m \times m \times m \times m}$ (e.g. 
		np.arange(16).reshape(2, 
		2, 2, 2))\\
		&with the condition $B \not= B^{T}$\\
		C &$\mathbb{R}^{m \times m \times n \times n}$ (e.g. 
		np.zeros((2, 2, 3, 3)))\\
		nspins&10\\
		nelec&4\\
		\bottomrule
	\end{tabular}
	\caption{Parameters used by the Density module tests.}
	\label{table:dmdata}
\end{table}

\begin{enumerate}
	
	\item{test\_assign\_rdms:  UT\refstepcounter{utnum}\theutnum 
		\label{UT6}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: Files onedm1 and twodm1, and number of electrons nelec (see 
	Table~\ref{table:dmdata}).
	
	Output: the loaded RDM matrices and the number of electrons and 
	spinorbitals.
	
	Test Case Derivation: N/A
	
	How test will be performed: Automated on unit testing framework. The 
	content of onedm1 and twodm1 will be read and stored externally into 
	variables and compared against the ones loaded by the module. The number of 
	sinorbitals will be compared with nspins (reported in 
	Table~\ref{table:dmdata}).
	
	\item{test\_check\_invalid\_rdms:  UT\refstepcounter{utnum}\theutnum 
		\label{UT7}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: nelec and the RDMs as specified by test case (C1-C) in 
	Table~\ref{table:wrongdms}. The values of nelec and the variables in 
	columns 2 and 3 are reported in Table~\ref{table:dmdata}.
	\begin{table}[h!]
		\centering
		\begin{tabular}{lccc}
			Case & $\boldsymbol{\gamma}$ & $\boldsymbol{\Gamma}$ & Exception  
			\\ \toprule
			C1   &    file1     &    twodm1    & ValueError \\
			C2   &    twodm1    &    twodm1    & ValueError \\
			C3   &    onedm1    &      C       & ValueError \\
			C4   &    onedm1    &      B       & ValueError \\ \bottomrule
		\end{tabular}
		\caption{Invalid RDMs input values. The test cases defined (C1-C4) 
			have corresponding input files in columns 2 and 3. Column 4 
			specifies the expected raised exception.}
		\label{table:wrongdms}
	\end{table}
	
	Output: An ValueError exception will be raised.
	
	Test Case Derivation: In test C1 the $\boldsymbol{\gamma}$ file is not a 
	NumPy .npy. In C2 to C3, the inputs have incorrect dimensions 
	($\boldsymbol{\gamma}$ has to be a square matrix, $\boldsymbol{\Gamma}$ 
	must be 4D with 
	equivalent dimensions)
	
	How test will be performed: Automated on unit testing framework.
	
	\item{test\_verify\_symmetry:  UT\refstepcounter{utnum}\theutnum 
		\label{UT8}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The RDMs for each test case (C1-C3) are listed in 
	columns 2 and 3 of Table~\ref{table:symmdms}. The number of electrons nelec 
	is also an input. (see Table~\ref{table:dmdata} for A, B, twodm1, onedm1 
	and nelec values).
	\begin{table}[h!]
		\centering
		\begin{tabular}{lccc}
			Case & $\boldsymbol{\gamma}$ & $\boldsymbol{\Gamma}$ & Exception  
			\\ \toprule
			C1   &      A       &   twodm1    & ValueError \\
			C2   &   onedm1    &      B       & ValueError \\
			C3   &   onedm1    &   twodm1    & ValueError \\ \bottomrule
		\end{tabular}
		\caption{Inputs with invalid symmetries. Three test cases are defined 
		(C1-C3) with corresponding input files in columns 2 and 3. Column 4 
			specifies the expected raised exception.}
		\label{table:symmdms}
	\end{table}
	
	Output: An ValueError exception is raised.
	
	Test Case Derivation: The matrices A and B must not have any element of 
	symmetry. While the file onedm1 has the correct symmetry for a 
	one-RDM, twodm1 does not meet the asymmetric permutations of 
	a two-RDM (see Data Definition 5 in SRS 
	[\cite{SRS2020}]).
	
	How test will be performed: Automated on unit testing framework.
	
	\item{test\_verify\_normalization:  UT\refstepcounter{utnum}\theutnum 
		\label{UT9}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: 
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{lcccc}
			Case & electrons & $\boldsymbol{\gamma}$ & $\boldsymbol{\Gamma}$ & 
			Exception  \\ 
			\toprule
			C1   &     2     &    onedm1    &    twodm1    & ValueError \\
			C2   &     4     &    onedm1    &    2*twodm1    & ValueError \\ 
			\bottomrule
		\end{tabular}
		\caption{Tests to verify the normalization condition of RDMS. Column 5 
			specifies the expected raised exception.}
		\label{table:normdms}
	\end{table}
	
	Output: An ValueError exception is raised.
	
	Test Case Derivation: The normalization condition of the RDMs is given by 
	their matrix trace (specified in Table 1 in the SRS [\cite{SRS2020}]); for 
	$\boldsymbol{\gamma}$ it must match the number of electrons, however in 
	test C1 the trace of onedm1 is 4. In test C2, the matrix for 
	$\boldsymbol{\Gamma}$ was multiplied by a factor to make the test fail.
	
	How test will be performed: Automated on unit testing framework.
	
\end{enumerate}


\subsubsection{Solver Module}
\label{sec:M12}

This section verify the Solver module described in 
Subsection 17 of the MIS [\cite{MIS2020}]. This is mainly a Software Decision 
Module (external libraries), therefore only the implementation component 
related to the transformation of a generalized eigenvalue problem to an 
ordinary one (the orthogonalization method, abbreviated as orthog) will be 
verified. The module takes two matrices (right and left-hand sides of the 
eigenvalue problem), a parameter to handle division by zero errors during 
matrix inversion, and an orthog method (one of symmetric or asymmetric). The 
test described bellow (\uref{UT10}) checks that for a specified N-electron 
system 
(e.g. an atom) the same result is obtained with either of the orthog methods.

\begin{enumerate}
	
	\item{test\_dense\_orthogonalization: UT\refstepcounter{utnum}\theutnum 
		\label{UT10}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The electron integrals and RDMs corresponding to the systems 
	presented in Table~\ref{table:solver} and an orthogonalization method (the 
	symmetric and asymmetric methods will be tried for each system).

	
	\begin{table}[h!]
		\centering
		\begin{tabular}{l c c c }
			\textbf{File} & IM & \textbf{Expected}&\textbf{tol}\\
			\midrule
			Be (STO-3G) & 1 & 0.91414765& 1e-6\\			
			He (STO-3G) & 1 & 0.25403769& 1e-8\\
		\end{tabular}
		\caption{Parameters for the tests: the systems whose integrals and RDMs 
		will be used (column 1), an IM (column 2), the expected energy value 
		for comparison (in Hartree) and the tolerance in the difference between 
		expected and calculated values (column 3).}
		\label{table:solver}
	\end{table}
	
	Output: The eigenvalues of IM1.
	
	Test Case Derivation: N/A
	
	How test will be performed: The testing framework will pass the input 
	parameters to the program. From the 
	solutions, the lowest eigenvalue will be selected and compared 
	against the "expected" value. If the absolute error is less or 
	equal than the tolerance criteria, the test will pass.

	
\end{enumerate}

\subsubsection{Output Module}
\label{sec:M13}

The test cases under this section verify the Output module described in 
Subsection 16 of the MIS [\cite{MIS2020}]. The module takes a filename, the 
energies and coefficients solution to the EOM eigenvalue problem, the 
corresponding TDM of the EOM method (this is optional) and a 
data structure storing input parameters (that will be called MockParsedParams). 
Three test cases have been 
considered whose target is to check that the expected output files are 
generated (in all cases a .out and .npz files must be produced). The number of 
lines in the .out file is also verified in each test case. This is particularly 
relevant when information about the transition energies is requested as part of 
the .ou file (trough the parameter ``MockParsedParams.roots").
Table~\ref{table:dumpdata} lists common input variables between these 
tests.
\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		Parameters& Description\\
		\midrule
		filename& example\_output.in\\
		delta\_E & [1.0, 2.0]\\ 
        coeffs& [[1.0, 2.0], [1.0, 2.0]]\\
        tdm& numpy.zeros((2, 2, 2))\\
        \bottomrule
	\end{tabular}
	\caption{Parameters used by all Output module tests.}
	\label{table:dumpdata}
\end{table}

\begin{enumerate}
	
	\item{test\_output\_dump: UT\refstepcounter{utnum}\theutnum 
		\label{UT11}\\}
	
	Type: Automatic
	
	Initial State: N/A
	
	Input: The parameters specified in Table~\ref{table:dumpdata} (which are 
	common for all cases) and the inputs that change in each test, listed in 
	Table~\ref{table:dumpcases} (C1-C3). Also, a MockParsedParams (structure 
	that stores the usual inputs of EOMEE (see the Input module from MIS 
	[\cite{MIS2020}]))  .
%	A filename: example\_output.in, params, excen, coeffs, tdms, num_files, 
%	num_outlines
	\begin{table}[h!]
		\centering
		\begin{tabular}{lccc}
			                       & \multicolumn{3}{c}{Test Cases} \\
			Parameters             &  C1  &  C2  &        C3        \\
			\toprule
			TDM                    & None & tdm  &       None       \\
			MockParsedParams.roots & None & None &        1         \\
			\#files                &  2   &  3   &        2         \\
			\#lines                &  17  &  17  &        21\\
			\bottomrule
		\end{tabular}
		\caption{Input parameters for the Output module tests. Column 1 
		specifies the variables, columns C1 to C3 their values in each test 
		case. \#files are the expected number of generated output files. 
		\#lines are the expected number of lines printed in the output file.}
		\label{table:dumpcases}
	\end{table}
	
	Output: An .out output file, a NumPy .npz file containing the energies and 
	coefficients, a NumPy .npy file with the TDMs for the case in 
	Table~\ref{table:dumpcases} where a TDM was specified.
	
	Test Case Derivation: N/A
	
	How test will be performed: The test framework will pass the inputs to the 
	Output module.
	
\end{enumerate}

%\subsubsection{Module 2}
%
%...

\subsection{Tests for Nonfunctional Requirements}

%\wss{If there is a module that needs to be independently assessed for
%  performance, those test cases can go here.  In some projects, planning for
%  nonfunctional tests of units will not be that relevant.}
%
%\wss{These tests may involve collecting performance data from previously
%  mentioned functional tests.}

This section is not applicable for the present project.

\subsection{Traceability Between Test Cases and Modules}
\label{section:unittraceability}

All modules considered as part of the Unit Testing Scope (Section 
\ref{sec:unitscope}) have been verified. Table~\ref{table:moduletraceab} shows 
the correspondence between modules and tests:

\begin{table}[ht]
	\centering
	\begin{tabular}{l|c|c|c|c|c|c|c|c}
		\hline
		&M1& M2& M3& M4& M5& M6-M11& M12& M13\\	\hline	
		\uref{UT1}-\uref{UT2}&  & & X& & & &&\\ \hline
		\uref{UT3}-\uref{UT5}&  & & &X & & &&\\ \hline
		\uref{UT6}-\uref{UT9}&  & & & &X & &&\\ \hline
		\uref{UT10}&  & & & & & &X&\\ \hline
		\uref{UT11}&  & & & & & &&X\\ \hline
	\end{tabular}
	\caption{Traceability for modules and unit test sections}
	\label{table:moduletraceab}
\end{table}

				
\bibliographystyle{plainnat}

\bibliography{../../refs/References}

\newpage

\section{Appendix}
\label{section:appendix}

%This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions}

\begin{enumerate}
	\item Were the installation instructions for your platform clear? Could you 
	successfully install EOMEE by following them?
	\item Was the code's documentation helpful when learning how to run the 
	calculations?
	\item Did you look at the tests files when learning how to run the 
	calculations? Were they helpful?
	\item Could you successfully run an excited state calculation?
	\item Could you successfully determine the transition density matrices for 
	your chosen EOM method?
	\item Was the naming of the functions descriptive (it was clear the 
	task they were supposed to perform)?
	\item Do you have any improvement suggestions regarding the documentation 
	or code?
	\item How would you rate the learning curve for this software?(Very easy, 
	easy, hard, very hard)
\end{enumerate}

\subsection{SRS Questionnaire}
\label{section:srsreview}
Because the members of the VnV team might have limited time to review the 
document some of the question bellow have been specifically assigned:
\begin{enumerate}
	\item Are the energy units in the Table of units (section 1.2) appropriate 
	for the physical problems EOMEE addresses?
	\item Was the Table of Symbols (section 1.2) complete? 
	\item Does the used notation in the Table of Symbols (section 1.2) matches 
	the one generally used in the literature? [Dr.\ Ayers]
	\item Were the abbreviations and acronyms (section 1.3) properly used 
	through the document?
	\item Is Figure 1 for the system context (section 3.1) along with its 
	description correct? Do the listed user and software responsibilities make 
	sense? [Dr. Smith and Mohamed AbuElAla]
	\item Was the description of the problem EOMEE intends to solve clear? Were 
	all the terminology definitions needed for the understanding of subsequent 
	sections included? (sections 4.1 and 4.1.1) [Dr.\ Smith 
	and Mohamed AbuElAla]
	\item Were the terminology definitions listed in section 4.1.1 correct? 
	[Dr.\ Ayers]
	\item Is section 4.1.2 (Physical System Description) clear? Do you have any 
	suggestions that might help improve the understanding of EOMEE's physical 
	system? [Mohamed AbuElAla]
	\item Were all assumptions pertinent to the EOM models included? Are the 
	ones listed correct?(section 4.2.1) [Dr.\ Ayers]
	\item Were the connections between the assumptions and the appropriate IM, 
	GS, DD, T or LC included? (section 4.2.1)
	\item Were the defined theoretical models the correct general equations 
	that EOMEE is based on? Were the descriptions and derivations appropriate? 
	(section 4.2.2) [Dr.\ Ayers]
	\item In section 4.2.3, are the definitions of the transition operator and 
	EOM approximations correct? Are the descriptions and derivations 
	appropriate? [Dr.\ Ayers]
	\item Are DD2, DD3, DD4 and DD5 properly described? Are the presented 
	symmetry properties of DD3 and DD5 correct? (section 4.2.4) [Dr.\ Ayers]
	\item Are the IMs inputs and outputs appropriate? (section 4.2.5) [Dr.\ 
	Smith]
	\item After reading the Input Data Constraints section (4.2.6), are the 
	physical constraints presented in the Table 1 correct? Are the typical 
	values assigned to the one- and two-electron integrals reasonable? What 
	changes do you suggested making to the values presented in this table? 
	[Dr.\ Ayers]
	\item Do the output constraints presented in Table 3 (section 4.2.7) make 
	sense? If not, could you suggest changes to be made? [Dr.\ Ayers]
	\item Do the listed Functional and Nonfunctional Requirements make sense 
	(sections 5.1 and 5.2 respectively) [Dr.\ Smith]
	\item Were the cross-references made correctly through the document? 
	[Mohamed AbuElAla]
	
\end{enumerate}
These questions are inspired on the SRS review plans by Malavika Srinivasan and 
Spencer Smith [\cite{malavika}]. 
\end{document}